# 连续分配管理方式

![](1.png)

连续分配：指为用户进程分配的必须是一个连续的内存空间。

## 单一连续分配

<img src="2.png" style="zoom:67%;" />

在单一连续分配方式中，内存被分为系统区和用户区。系统区通常位于内存的低地址部分，用于存放操作系统相关数据；用户区用于存放用户进程相关数据。内存中只能有一道用户程序，用户程序独占整个用户区间。

优点：实现简单；无外部碎片；可以采用覆盖技术扩充内存；不一定需要采取内存保护（e.g. 早期的PC操作系统MS-DOS）。

缺点：只能用于单用户、单任务的操作系统中；有内部碎片；存储器利用率低。

内存碎片：分配给某进程的内存区域中，如果有些部分没有用上，就是“内部碎片”

有很大一部分用户区空闲，内存利用率低。

## 固定分区分配

20世纪60年代出现了支持多道程序的系统，为了能在内存中装入多道程序，且这些程序之间又不会相互干扰，于是将整个用户空间划分为若干个固定大小的分区，在每个分区中只装入一道作业，这样就形成了最早的、最简单的一种可运行多道程序的内存管理方式。

<img src="3.png" style="zoom:67%;" />

分区大小相等：缺乏灵活性，但是很适合用于用一台计算机控制多个相同对象的场合（比如：钢铁厂有n个相同的炼钢炉，就可把内存分为n个大小相等的区域存放n个炼钢炉控制程序）

<img src="4.png" style="zoom:67%;" />

分区大小不等：增加了灵活性，可以满足不同大小的进程需求。根据常在系统中运行的作业大小情况进行划分（比如：划分多个小分区、适量中等分区、少量大分区）

操作系统需要建立一个数据结构——分区说明表，来实现各个分区的分配与回收。每个表项对应一个分区，通常按分区大小排列。每个表项包括对应分区的大小、起始地址、状态（是否已分配）

用数据结构的数组（或链表）即可表示这个表

<img src="5.png" style="zoom:67%;" />

当某用户程序要装入内存时，由操作系统内核程序根据用户程序大小检索该表，从中找到一个能满足大小的、未分配的分区，将之分配给该程序，然后修改状态为“已分配”。

![](6.png)

优点：实现简单，无外部碎片。

缺点：a.当用户程序太大时，可能所有的分区都不能满足需求，此时不得不采用覆盖技术来解决，但这又会降低性能；b.会产生内部碎片，内存利用率低。

## 动态分区分配

动态分区分配又称为可变分区分配。这种分配方式不会预先划分内存分区，而是在进程装入内存时，根据进程的大小动态地建立分区，并使分区的大小正好适合进程的需要。因此系统分区的大小和数目是可变的。（e.g. 假设某计算机内存大小为64MB，系统区8MB，用户区共56MB...）

1. 系统要用什么样的数据结构记录内存的使用情况？

   ![](7.png)

   <img src="9.png" style="zoom:67%;" />

   ![](8.png)

   空闲分区表：每个空闲分区对应一个表项。表项中包含分区号、分区大小、分区起始地址等信息

   空闲分区链：每个分区的起始部分和末尾部分分别设置前向指针和后向指针。起始部分处还可记录分区大小等信息

   把一个新作业装入内存时，须按照一定的动态分区分配算法，从空闲分区表（或空闲分区链）中选出一个分区分配给该作业。由于分配算法对系统性能有很大的影响，因此人们对它进行了广泛的研究。

2. 当很多个空闲分区都能满足需求时，应该选择哪个分区进行分配？

   假设系统采用的数据结构是“空闲分区表”...

   如何分配？

   ![](10.png)

   ![](11.png)

3. 如何进行分区的分配与回收操作？

   假设系统采用的数据结构是“空闲分区表”...

   如何回收？

   情况一：回收区的后面有一个相邻的空闲分区

   ![](12.png)

   情况二：回收区的前面有一个相邻的空闲分区

   ![](13.png)

   情况三：回收区的前、后各有一个相邻的空闲分区

   ![](14.png)

   情况四：回收区的前、后都没有相邻的空闲分区

   新增一个表项

   注：各表项的顺序不一定按照地址递增顺序排列，具体的排列方式需要依据动态分区分配算法来确定。

   ![](15.png)

   动态分区分配没有内部碎片，但是有外部碎片。

   内部碎片：分配给某进程的内存区域中，如果有些部分没有用上。

   外部碎片：是指内存中的某些空闲分区由于太小而难以利用。

   如果内存中空闲空间的总和本来可以满足某些进程的要求，但由于进程需要的是一整块连续的内存空间，因此这些”碎片“不能满足进程的需求。

   可以通过紧凑（拼凑，Compaction）技术来解决外部碎片。

   1. 回忆交换技术，什么是换入/换出

      什么是中级调度（内存调度）？

   2. 思考动态分区分配应使用哪种装入方式？”紧凑“之后需要做什么处理？

![](16.png)

# 指令系统

## 现代计算机的结构

![](17.png)

操作码：指明了”做什么“

地址码：指明了”对谁动手“

有的指令不需要地址码（停机）

![](18.png)

## 本节总览

![](19.png)

## 指令的定义

指令（又称机器指令）：

是指计算机执行某种操作的命令，是计算机运行的最小功能单位。

一台计算机的所有指令的集合构成该机的指令系统，也称为指令集。

注：一台计算机只能执行自己指令系统中的指令，不能执行其他系统的指令。

![](20.png)

e.g. x86架构、ARM架构

## 指令格式

一条指令就是机器语言的一个语句，它是一组有意义的二进制码

一条指令通常要包括操作码字段和地址码字段两部分

![](21.png)

一条指令可能包含0个、1个、2个、3个、4个地址码...

根据地址码数目不同，可以将指令分为零地址指令、一地址指令、二地址指令...

## 零地址指令

零地址指令

![](23.png)

1. 不需要操作数，如空操作、停机、关中断等指令
2. 堆栈计算机，两个操作数隐含存放在栈顶和次栈顶，计算结果压回栈顶

<img src="22.png" style="zoom:67%;" />

## 一地址指令

一地址指令

1. 只需要单操作数，如加1、减1、取反、求补等

   指令含义：OP(A1)->A1，完成一条指令需要3次访存：取指->读A1->写A1

2. 需要两个操作数，但其中一个操作数隐含在某个寄存器（如隐含在ACC）

   指令含义：(ACC)OP(A1)->ACC，完成一条指令需要2次访存：取指->读A1

注：A1指某个主存地址，(A1)表示A1所指向的地址中的内容

类比A1C语言指针 (A1)指针所指位置的内容

## 二、三地址指令

### 二地址指令

![](24.png)

常用于需要两个操作数的算术运算、逻辑运算相关指令

指令含义：(A1)OP(A2)->A1

完成一条指令需要访存4次，取指->读A1->读A2->写A1

### 三地址指令

常用于需要两个操作数的算术运算、逻辑运算相关指令

指令含义：(A1)OP(A2)->A3

完成一条指令需要访存4次，取指->读A1->读A2->写A3

## 四地址指令

四地址指令

![](25.png)

指令含义：(A1)OP(A2)->A3，A4=下一条将要执行指令的地址

完成一条指令需要访存4次，取指->读A1->读A2->写A3

正常情况下：取指令之后PC+1，指向下一条指令

四地址指令：执行指令后，将PC的值修改为A4所指地址

地址码的位数有什么影响？

n位地址码的直接寻址范围=2^n

若指令总长度固定不变，则地址码数量越多，寻址能力越差

## 指令-按地址码数目分类

![](26.png)

## 指令-按指令长度分类

指令字长：一条指令的总长度（可能会变）

机器字长：CPU进行一次整数运算所能处理的二进制数据的位数（通常和ALU直接相关）

存储字长：一个存储单元中的二进制代码位数（通常和MDR位数相同）

半字长指令、单字长指令、双字长指令——指令长度是机器字长的多少倍

指令字长会影响取指令所需时间。如：机器字长=存储字长=16bit，则取一条双字长指令需要两次访存

定长指令字结构：指令系统中所有指令的长度都相等

变长指令字结构：指令系统中各种指令的长度不等

## 指令-按操作码长度分类

定长操作码：指令系统中所有指令的操作码长度都相同

n位->2^n条指令

控制器的译码电路设计简单，但灵活性较低

可变长操作码：指令系统中各指令的操作码长度可变

控制器的译码电路设计复杂，但灵活性较高

定长指令字结构+可变长操作码->扩展操作码指令格式

## 指令-按操作类型分类

1. 数据传送 数据传送类：进行主存与CPU之间的数据传送

   LOAD 作用：把存储器中的数据放到寄存器中

   STORE 作用：把寄存器中的数据放到存储器中

2. 算术逻辑操作 运算类

   算术：加、减、乘、除、增1、减1、求补、浮点运算、十进制运算

   逻辑：与、或、非、异或、位操作、位测试、位清除、位求反

3. 移位操作 运算类

   算术移位、逻辑移位、循环移位（带进位和不带进位）

4. 转移操作 程序控制类：改变程序执行的顺序

   无条件转移 JMP

   条件转移 JZ：结果为0

   JO：结果溢出

   JC：结果有进位

   调用和返回CALL和RETURN

   陷阱（Trap）与陷阱指令

5. 输入输出操作 输入输出类（I/O）：进行CPU和I/O设备之间的数据传送

   CPU寄存器与IO端口之间的数据传送（端口即IO接口中的寄存器）

![](27.png)

# 扩展操作码指令格式

## 指令寻址

## 数据寻址

## 数据寻址 偏移寻址

## 数据寻址 堆栈寻址

高级语言与机器级代码之间的对应

常用的x86汇编指令

AT&T格式和Intel格式

选择语句的机器级表示

循环语句的机器级表示

call和ret指令（函数调用的机器级表示）